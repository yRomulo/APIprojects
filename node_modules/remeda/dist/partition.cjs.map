{"version":3,"file":"partition.cjs","names":["purry","ret: [S[], T[]]"],"sources":["../src/partition.ts"],"sourcesContent":["import { purry } from \"./purry\";\n\n/**\n * Splits a collection into two groups, the first of which contains elements the\n * `predicate` type guard passes, and the second one containing the rest.\n *\n * @param data - The items to split.\n * @param predicate - A function to execute for each element in the array. It\n * should return `true` to add the element to the first partition, and and\n * `false` to add the element to the other partition. A type-predicate can also\n * be used to narrow the result.\n * @returns A 2-tuple of arrays where the first array contains the elements that\n * passed the predicate, and the second array contains the elements that did\n * not. The items are in the same order as they were in the original array.\n * @signature\n *    R.partition(data, predicate)\n * @example\n *    R.partition(\n *      ['one', 'two', 'forty two'],\n *      x => x.length === 3,\n *    ); // => [['one', 'two'], ['forty two']]\n * @dataFirst\n * @category Array\n */\nexport function partition<T, S extends T>(\n  data: readonly T[],\n  predicate: (value: T, index: number, data: readonly T[]) => value is S,\n): [S[], Exclude<T, S>[]];\nexport function partition<T>(\n  data: readonly T[],\n  predicate: (value: T, index: number, data: readonly T[]) => boolean,\n): [T[], T[]];\n\n/**\n * Splits a collection into two groups, the first of which contains elements the\n * `predicate` type guard passes, and the second one containing the rest.\n *\n * @param predicate - A function to execute for each element in the array. It\n * should return `true` to add the element to the first partition, and and\n * `false` to add the element to the other partition. A type-predicate can also\n * be used to narrow the result.\n * @returns A 2-tuple of arrays where the first array contains the elements that\n * passed the predicate, and the second array contains the elements that did\n * not. The items are in the same order as they were in the original array.\n * @signature\n *    R.partition(predicate)(data)\n * @example\n *    R.pipe(\n *      ['one', 'two', 'forty two'],\n *      R.partition(x => x.length === 3),\n *    ); // => [['one', 'two'], ['forty two']]\n * @dataLast\n * @category Array\n */\nexport function partition<T, S extends T>(\n  predicate: (value: T, index: number, data: readonly T[]) => value is S,\n): (data: readonly T[]) => [S[], Exclude<T, S>[]];\nexport function partition<T>(\n  predicate: (value: T, index: number, data: readonly T[]) => boolean,\n): (data: readonly T[]) => [T[], T[]];\n\nexport function partition(...args: readonly unknown[]): unknown {\n  return purry(partitionImplementation, args);\n}\n\nconst partitionImplementation = <T, S extends T>(\n  data: readonly T[],\n  predicate: (value: T, index: number, data: readonly T[]) => value is S,\n): [S[], T[]] => {\n  const ret: [S[], T[]] = [[], []];\n  for (const [index, item] of data.entries()) {\n    if (predicate(item, index, data)) {\n      ret[0].push(item);\n    } else {\n      ret[1].push(item);\n    }\n  }\n  return ret;\n};\n"],"mappings":"wCA6DA,SAAgB,EAAU,GAAG,EAAmC,CAC9D,OAAOA,EAAAA,EAAM,EAAyB,EAAK,CAG7C,MAAM,GACJ,EACA,IACe,CACf,IAAMC,EAAkB,CAAC,EAAE,CAAE,EAAE,CAAC,CAChC,IAAK,GAAM,CAAC,EAAO,KAAS,EAAK,SAAS,CACpC,EAAU,EAAM,EAAO,EAAK,CAC9B,EAAI,GAAG,KAAK,EAAK,CAEjB,EAAI,GAAG,KAAK,EAAK,CAGrB,OAAO"}