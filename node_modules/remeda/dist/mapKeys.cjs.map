{"version":3,"file":"mapKeys.cjs","names":["purry","out: Partial<Record<Key, unknown>>"],"sources":["../src/mapKeys.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-object-type --\n * We want to match the typing of the built-in Object.entries as much as\n * possible!\n */\n\nimport type { And, IsUnion, Or } from \"type-fest\";\nimport type { EnumerableStringKeyedValueOf } from \"./internal/types/EnumerableStringKeyedValueOf\";\nimport type { EnumerableStringKeyOf } from \"./internal/types/EnumerableStringKeyOf\";\nimport type { IsBounded } from \"./internal/types/IsBounded\";\nimport { purry } from \"./purry\";\n\ntype MappedKeys<T, Key extends PropertyKey> = MaybePartial<\n  T,\n  Key,\n  // We re-key `T` using `Key`, but because we can't infer at the type level\n  // how the mapper would map each specific input key we assign all props the\n  // same value, made of all possible values of `T`.\n  Record<Key, EnumerableStringKeyedValueOf<T>>\n>;\n\n/**\n * This type is very similar to `BoundedPartial` simplified to the case where\n * we reconstruct the Record using a known `Key` type.\n *\n * @see BoundedPartial\n */\ntype MaybePartial<T, Key extends PropertyKey, Output> =\n  And<IsBounded<Key>, Or<IsUnion<Key>, CouldBeEmpty<T>>> extends true\n    ? // When keys are bounded we need to consider what assurances we can make\n      // about the presence of keys in the output; mainly if there is more than\n      // one possible result from the mapper (so we can't know what it would\n      // return for a specific input, at the type level), or if object itself\n      // might be empty and thus also the output object.\n      Partial<Output>\n    : // If keys are not bounded TypeScript treats the Record as implicitly\n      // Partial so we don't need to do that here.\n      Output;\n\n/**\n * Types that are extendable by `{}` are also satisfied by an empty object and\n * thus _could be empty_.\n */\ntype CouldBeEmpty<T> = {} extends T ? true : false;\n\n/**\n * Maps keys of `object` and keeps the same values.\n *\n * @param data - The object to map.\n * @param keyMapper - The mapping function.\n * @signature\n *    R.mapKeys(object, fn)\n * @example\n *    R.mapKeys({a: 1, b: 2}, (key, value) => key + value) // => { a1: 1, b2: 2 }\n * @dataFirst\n * @category Object\n */\nexport function mapKeys<T extends {}, Key extends PropertyKey>(\n  data: T,\n  keyMapper: (\n    key: EnumerableStringKeyOf<T>,\n    value: EnumerableStringKeyedValueOf<T>,\n    data: T,\n  ) => Key,\n): MappedKeys<T, Key>;\n\n/**\n * Maps keys of `object` and keeps the same values.\n *\n * @param keyMapper - The mapping function.\n * @signature\n *    R.mapKeys(fn)(object)\n * @example\n *    R.pipe({a: 1, b: 2}, R.mapKeys((key, value) => key + value)) // => { a1: 1, b2: 2 }\n * @dataLast\n * @category Object\n */\nexport function mapKeys<T extends {}, Key extends PropertyKey>(\n  keyMapper: (\n    key: EnumerableStringKeyOf<T>,\n    value: EnumerableStringKeyedValueOf<T>,\n    data: T,\n  ) => Key,\n): (data: T) => MappedKeys<T, Key>;\n\nexport function mapKeys(...args: readonly unknown[]): unknown {\n  return purry(mapKeysImplementation, args);\n}\n\nfunction mapKeysImplementation<T extends {}, Key extends PropertyKey>(\n  data: T,\n  keyMapper: (key: string, value: unknown, data: T) => Key,\n): Partial<Record<Key, unknown>> {\n  const out: Partial<Record<Key, unknown>> = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    const mappedKey = keyMapper(key, value, data);\n    out[mappedKey] = value;\n  }\n\n  return out;\n}\n"],"mappings":"wCAoFA,SAAgB,EAAQ,GAAG,EAAmC,CAC5D,OAAOA,EAAAA,EAAM,EAAuB,EAAK,CAG3C,SAAS,EACP,EACA,EAC+B,CAC/B,IAAMC,EAAqC,EAAE,CAE7C,IAAK,GAAM,CAAC,EAAK,KAAU,OAAO,QAAQ,EAAK,CAAE,CAC/C,IAAM,EAAY,EAAU,EAAK,EAAO,EAAK,CAC7C,EAAI,GAAa,EAGnB,OAAO"}